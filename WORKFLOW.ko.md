# 포괄적인 Claude Code 워크플로우 가이드

Claude Code를 활용하여 생산성을 극대화하는 완전한 가이드입니다.

**이 문서는 무엇인가요?** 이 문서는 Claude Code를 효과적으로 사용하기 위한 단일 진실 공급원(Single Source of Truth)입니다. Boris Cherny와 Everything-Claude-Code의 모범 사례를 결합하고, 실제 운영 환경에서 검증된 패턴, 보안 우선 워크플로우, 팀 협업 전략으로 강화되었습니다.

**누구를 위한 것인가요?** 개인이든 팀이든, 처음 시작하는 개발자부터 파워 유저까지 Claude Code를 도입하는 모든 개발자를 위한 것입니다.

**빠른 내비게이션:**
- 📋 **[.claude/agents/INDEX.md](.claude/agents/INDEX.md)** - 에이전트 디렉토리 및 사용 가이드
- 📚 **[.claude/skills/INDEX.md](.claude/skills/INDEX.md)** - 스킬 디렉토리 및 선택 가이드
- ⚡ **[README.md](README.md)** - 프로젝트 개요

---

## 목차

1. [철학과 핵심 개념](#1-철학과-핵심-개념)
2. [빠른 의사결정 트리](#2-빠른-의사결정-트리)
3. [완전한 워크플로우 패턴](#3-완전한-워크플로우-패턴)
4. [에이전트 오케스트레이션](#4-에이전트-오케스트레이션)
5. [MCP 서버 통합](#5-mcp-서버-통합)
6. [성능 및 최적화](#6-성능-및-최적화)
7. [커스터마이제이션 로드맵](#7-커스터마이제이션-로드맵)
8. [팀 협업](#8-팀-협업)
9. [문제 해결](#9-문제-해결)
10. [고급 주제](#10-고급-주제)

---

## 1. 철학과 핵심 개념

### 1.1 강화된 철학

이 템플릿은 세 가지 강력한 접근 방식을 통합합니다:

**Boris Cherny로부터:**
- **복합적 엔지니어링**: CLAUDE.md는 모든 실수와 함께 성장하며 팀 지식 기반을 만듭니다
- **검증 루프**: 지속적인 검증을 통해 품질을 2-3배 향상시킵니다
- **계획 모드 우선**: 구현 전에 항상 복잡한 작업을 계획합니다
- **병렬 세션**: 여러 Claude 세션을 동시에 실행합니다
- **모델 선택**: 작업 복잡도에 맞는 모델을 선택합니다 (Haiku/Sonnet/Opus)

**Everything-Claude-Code로부터:**
- **가드레일로서의 규칙**: 항상 활성화된 품질 강제로 실수를 자동으로 방지합니다
- **지식으로서의 스킬**: 재사용 가능한 패턴이 반복을 줄이고 일관성을 보장합니다
- **컨텍스트 관리**: 200k → 70k 성능 저하 문제에 대한 실전 테스트된 인식
- **에이전트 위임**: 격리된 컨텍스트를 가진 특화된 에이전트에게 전문 작업을 위임합니다
- **커뮤니티 확장성**: 도메인별 지식을 위한 플러그인 생태계

**우리만의 고유한 통합:**
- **보안 우선**: 전용 보안 규칙 + 에이전트 + 명령어로 보안을 자동화합니다
- **다중 환경**: 개발/운영 구성으로 프로덕션 안전성을 보장합니다
- **점진적 도입**: 몇 주 안에 빠른 시작부터 완전한 파워 유저까지
- **팀 준비**: 공유 CLAUDE.md를 통한 협업 개발을 위해 설계되었습니다
- **실전 검증**: 실제 컨텍스트 임계값 및 성능 패턴

### 1.2 핵심 원칙

**원칙 1: 메인 에이전트가 먼저 코딩합니다**
메인 에이전트는 표준 개발 작업(CRUD, 간단한 기능, 버그 수정)을 직접 처리합니다. 복잡한 도메인(인증, 데이터베이스 스키마, 보안, 성능)에만 전문가에게 위임하세요.

**원칙 2: 복잡한 작업은 계획하세요**
5개 이상의 파일을 다루거나 아키텍처 결정이 필요한 복잡한 기능의 경우 플랜 모드(`Shift+Tab` 두 번)를 사용하세요. 대부분의 간단한 기능은 계획이 필요하지 않습니다.

**원칙 3: 지속적으로 검증하세요**
모든 커밋 전에 `/test-and-build`와 `/security-review`를 실행하세요. 검증 루프는 품질을 2-3배 향상시킵니다.

**원칙 4: 전문가에게 위임하세요**
도메인 전문성(auth-specialist, security-reviewer, performance-optimizer 등)이 필요한 경우 전문 에이전트를 사용하세요. 에이전트는 격리된 컨텍스트와 집중된 전문성을 가지고 있습니다.

**원칙 5: 지식을 축적하세요**
모든 실수 후에 CLAUDE.md를 업데이트하세요. 팀의 공유 지식은 프로젝트와 함께 성장합니다.

**원칙 6: 컨텍스트를 관리하세요**
컨텍스트 사용량을 80k 토큰 이하로 유지하세요. 사용하지 않는 MCP를 비활성화하고, 무거운 작업을 에이전트에 위임하며, 필요할 때 새로운 세션을 시작하세요.

### 1.3 시스템 개요

**하이브리드 에이전트 모델** - 메인 에이전트가 코딩하고, 전문가가 전문성을 제공
- 메인 에이전트가 70%의 작업을 직접 처리 (CRUD, 간단한 기능, 버그 수정)
- 복잡한 도메인을 위한 33개의 전문 에이전트 사용 가능
- 효율적인 워크플로우: 먼저 코딩하고, 전문 지식이 필요할 때 위임

**명령어(Commands)** - 사용자가 트리거하는 워크플로우
- `/full-feature`, `/commit-push-pr`, `/lint-fix`, `/type-check` 같은 슬래시 명령어
- 하나의 명령어로 전체 워크플로우 실행
- **20개의 명령어 사용 가능** 워크플로우 오케스트레이션, 개발, 품질, 유지보수를 다룸

**에이전트(Agents)** - 전문화된 자율 작업자 (총 33개)
- 메인 에이전트는 표준 작업을 직접 코딩
- 도메인 전문성이 필요한 경우 전문가에게 위임
- 에이전트는 격리된 컨텍스트와 특정 도구를 가집니다
- 카테고리: 계획 및 아키텍처 (2), 코드 품질 (6), 테스트 (6), 개발 (5), 운영 (6), 접근성 및 i18n (2), 문서화 (2), 성능 (1), 특수 도메인 (3)

**규칙(Rules)** - 항상 활성화된 가드레일
- 핵심 가이드라인: `essential-rules.md` (보안, 코딩 스타일, TypeScript, 테스트, 에러 처리, API 디자인)
- 워크플로우 규칙: `agent-workflow.md` (하이브리드 모델 위임 원칙)
- 모든 상호작용에서 자동으로 강제됩니다

**스킬(Skills)** - 재사용 가능한 지식 패턴 (총 20개)
- 메인 에이전트와 전문 에이전트가 참조합니다
- 반복을 줄이고 일관성을 보장합니다
- 카테고리: 프레임워크 패턴 (React, Next.js, Node.js), API 디자인 (REST, GraphQL, WebSocket), 개발 관행 (TDD, 인증, 데이터베이스, 문서화), 프로젝트 관리 (가이드라인, 사용자 의도, 프롬프트 엔지니어링)

**워크플로우(Workflows)** - 오케스트레이션된 시퀀스
- 다단계 자동화 워크플로우
- **5개의 워크플로우**: full-feature, bug-fix, refactor, release, security-audit

**체크리스트(Checklists)** - 검토 표준
- 품질 게이트를 위한 포괄적인 체크리스트
- **13개의 체크리스트**: PR 검토, 보안 감사, 성능 감사, 접근성 감사, 출시 전, 온보딩, 배포, 데이터베이스 마이그레이션, 의존성 감사, 핫픽스, AI 코드 리뷰, 빌드 오류, E2E 테스트

**템플릿(Templates)** - 코드 스캐폴딩
- 일반적인 패턴을 위한 재사용 가능한 코드 템플릿
- **16개의 템플릿**: component, API route, test, migration, PR description, form, guard, hook, service, middleware, error-handler, Dockerfile, GitHub workflow, Playwright config, API docs, README

**스크립트(Scripts)** - 자동화 헬퍼
- 일반적인 자동화 작업을 위한 셸 스크립트
- **5개의 스크립트**: pre-commit checks, test gating, security logging, auto-format, sync-deps

**MCP 서버** - 외부 도구 통합
- **27개의 사전 구성된 서버** (대부분 기본적으로 비활성화)
- 필요한 것만 활성화하세요 (filesystem, github, database, deployment, docker, playwright 등)
- 최적 성능을 위해 활성화된 개수를 10개 미만으로 유지하세요

---

## 2. 빠른 의사결정 트리

### 2.1 "내가 해야 할 일은..." 의사결정 트리

```
내가 해야 할 일은...

├─ 새로운 기능 추가
│  ├─ 간단함 (<3개 파일) → 바로 구현
│  ├─ 중간 (3-10개 파일) → /plan 먼저, 그다음 구현
│  └─ 복잡함 (>10개 파일) → 플랜 모드 + planner 에이전트

├─ 버그 수정
│  ├─ 알려진 수정 → 바로 구현
│  ├─ 조사 필요 → 구현, 그다음 verify-app 에이전트
│  └─ 복잡한 근본 원인 → 플랜 모드 + 조사

├─ 코드 리팩토링
│  ├─ 작은 리팩토링 (<5개 파일) → 바로 구현
│  ├─ 모듈 리팩토링 → /refactor-clean 명령어
│  └─ 아키텍처 변경 → 플랜 모드 + architect 에이전트

├─ 오류 처리
│  ├─ 빌드 오류 → /build-fix 명령어
│  ├─ 테스트 실패 → /test-and-build (자동 수정)
│  └─ 보안 문제 → /security-review 명령어

├─ 테스트 작성
│  ├─ 단위 테스트 → /tdd (TDD 접근 방식)
│  ├─ E2E 테스트 → /e2e 명령어
│  └─ 커버리지 확인 → /test-coverage 명령어

└─ 배포/릴리스
   ├─ 일반 릴리스 → /commit-push-pr
   ├─ 중요 릴리스 → 전체 검증 워크플로우
   └─ 핫픽스 → 필수 검증을 통한 빠른 트랙
```

### 2.2 명령어 선택 매트릭스

| 상황 | 명령어 | 사용 이유 |
|------|--------|-----------|
| 기능 추가 | `/plan` 후 구현 | 품질을 위해 먼저 계획 |
| 테스트 작성 | `/tdd` | 테스트 주도 개발 접근 방식 |
| 빌드 수정 | `/build-fix` | 자동화된 체계적 오류 해결 |
| 리팩토링 | `/refactor-clean` | 체계적 정리 및 현대화 |
| 커밋 전 | `/security-review` + `/review-changes` | 품질 게이트 |
| PR 생성 | `/commit-push-pr` | 전체 워크플로우 자동화 |
| 앱 테스트 | `/e2e` | 사용자 워크플로우 검증 |
| 커버리지 확인 | `/test-coverage` | 격차 식별 및 우선순위 지정 |
| 품질 확인 | `/test-and-build` | 종합적 검증 |
| 문서 업데이트 | `/update-docs` | 문서를 동기화 상태로 유지 |

### 2.3 에이전트 선택 매트릭스

| 작업 유형 | 에이전트 | 사용 시기 |
|-----------|---------|-----------|
| 계획 | `planner` | 범위가 불명확한 복잡한 기능 |
| 아키텍처 | `architect` | 설계 결정 및 트레이드오프 |
| 단순화 | `code-simplifier` | 과도하게 엔지니어링된 코드 |
| 현대화 | `refactor-cleaner` | 레거시 코드 업데이트 |
| 테스트 | `tdd-guide` | TDD 학습 또는 테스트 우선 접근 |
| E2E 테스트 | `e2e-runner` | 사용자 워크플로우 테스트 |
| 검증 | `verify-app` | 엔드투엔드 검증 |
| 빌드 오류 | `build-error-resolver` | 체계적 오류 수정 |
| 문서화 | `doc-updater` | 코드와 문서를 동기화 |
| 보안 | `security-reviewer` | 취약점 스캔 및 감사 |

### 2.4 모델 선택 가이드

| 작업 복잡도 | 모델 | 비용 | 속도 | 최적 사용처 |
|-------------|------|------|------|------------|
| 간단함 | Haiku | $ | 빠름 | 포맷팅, 간단한 수정, 빠른 검사 |
| 표준 | Sonnet | $$ | 중간 | 대부분의 개발, 리팩토링, 테스트 (기본값) |
| 복잡함 | Opus | $$$ | 느림 | 아키텍처, 중요한 결정, 보안 |

**기본 구성**: Sonnet (대부분의 작업에 균형잡힘)

**Haiku로 전환해야 할 때**:
- Prettier/ESLint로 코드 포맷팅
- 간단한 한 줄 수정
- 테스트 반복 실행
- 빠른 리팩토링 (<10줄)

**Opus로 전환해야 할 때**:
- 시스템 아키텍처 설계
- 보안이 중요한 코드
- 프로덕션 인시던트
- 복잡한 알고리즘
- 대규모 리팩토링

---

## 3. 완전한 워크플로우 패턴

### 3.1 새로운 기능 개발 (전체 사이클)

**1단계: 계획 단계** (중간/복잡한 기능의 경우)

```
3개 이상의 파일을 다루는 기능의 경우:
[Shift+Tab 두 번] 또는 /plan

→ planner 에이전트가 구현 계획을 생성합니다
→ 계획을 신중히 검토합니다
→ 명확히 하기 위해 질문합니다
→ 필요한 경우 변경을 요청합니다
→ 계획이 완성되면 승인합니다
```

**2단계: 구현 단계**

옵션 A - TDD 접근 방식 (권장):
```
/tdd "기능 이름"
→ tdd-guide 에이전트가 Red-Green-Refactor 과정을 안내합니다
→ 먼저 실패하는 테스트를 작성합니다
→ 통과하는 최소한의 코드를 구현합니다
→ 테스트 안전망과 함께 리팩토링합니다
```

옵션 B - 일반 구현:
```
승인된 계획에 따라 구현합니다
→ 코드가 복잡하게 느껴지면 code-simplifier 에이전트를 사용합니다
→ CLAUDE.md의 프로젝트 패턴을 따릅니다
```

**3단계: 검증 단계**

```
/e2e "테스트할 사용자 워크플로우"
→ e2e-runner가 Playwright/Cypress 테스트를 생성합니다
→ 중요한 사용자 플로우를 테스트합니다

verify-app 에이전트
→ 엔드투엔드 애플리케이션 테스트
→ 통합 검증
```

**4단계: 품질 게이트** (커밋 전 필수)

```
/security-review
→ security-reviewer가 취약점을 스캔합니다
→ OWASP Top 10 검사, 시크릿 탐지

/review-changes
→ 종합적 코드 리뷰
→ 품질 검사, 모범 사례

/test-and-build
→ 모든 테스트 + 빌드 실행
→ 통과할 때까지 문제 자동 수정
```

**5단계: 릴리스 단계**

```
/commit-push-pr
→ Conventional Commits 형식으로 커밋합니다
→ 원격 브랜치에 푸시합니다
→ 다음 내용으로 풀 리퀘스트를 생성합니다:
   - 변경 사항 요약
   - 테스트 계획 체크리스트
   - Claude Code로 생성됨 표시
```

### 3.2 실제 예제: 사용자 인증 추가

**JWT 토큰을 사용한 인증 구현의 완전한 연습:**

```markdown
사용자: "JWT 토큰을 사용한 이메일/비밀번호 인증을 추가해야 합니다"

Claude (플랜 모드): [상세한 계획 생성]
─────────────────────────────────────────────────────────
구현 계획: 사용자 인증

1. 데이터베이스 스키마
   - users 테이블 생성 (id, email, password_hash, created_at)
   - email에 고유 제약 조건 추가
   - 마이그레이션 파일 생성

2. API 라우트
   - POST /api/auth/register (계정 생성)
   - POST /api/auth/login (JWT 토큰 획득)
   - GET /api/auth/me (현재 사용자 가져오기)
   - Zod 스키마로 유효성 검사 추가

3. 인증 미들웨어
   - JWT 토큰 검증
   - 요청에 사용자 첨부
   - 토큰 만료 처리

4. 프론트엔드 컴포넌트
   - LoginForm 컴포넌트 (이메일 + 비밀번호)
   - RegisterForm 컴포넌트 (이메일 + 비밀번호 + 확인)
   - 보호된 라우트 래퍼

5. 보안 고려사항
   - 비밀번호 해싱에 bcrypt 사용 (10 라운드)
   - JWT를 httpOnly 쿠키에 저장
   - 짧은 만료 시간 (15분 액세스, 7일 갱신)
   - 로그인 엔드포인트에 속도 제한 추가
   - 상태 변경 요청을 위한 CSRF 보호

설치할 의존성:
- jsonwebtoken
- bcrypt
- zod (유효성 검사용)
─────────────────────────────────────────────────────────

사용자: "승인합니다, 진행하세요"

Claude: [계획에 따라 구현]
→ 데이터베이스 마이그레이션 생성
→ 유효성 검사와 함께 API 라우트 구현
→ 인증 미들웨어 생성
→ 프론트엔드 컴포넌트 구축
→ 오류 처리 추가

사용자: "auth 서비스에 code-simplifier 에이전트를 실행하세요"

Claude (code-simplifier 에이전트): [auth 서비스 분석]
─────────────────────────────────────────────────────────
단순화 보고서:

✅ 개선 사항:
1. 중복 유효성 검사 로직 제거
   - 공유 validateEmail() 함수로 추출
   - register와 login 모두에서 사용

2. JWT 처리 단순화
   - generateToken() 유틸리티 생성
   - verifyToken() 유틸리티 생성
   - auth 미들웨어를 30줄에서 12줄로 축소

3. 오류 처리 개선
   - 오류 응답 형식 통일
   - createError() 헬퍼로 추출
   - 사용자를 위한 더 명확한 오류 메시지
─────────────────────────────────────────────────────────

사용자: "/e2e 로그인 및 회원가입 플로우"

Claude (/e2e 명령어): [Playwright 테스트 생성]
─────────────────────────────────────────────────────────
생성된 E2E 테스트:

test/e2e/auth.spec.ts:
- ✅ 유효한 데이터로 사용자 등록
- ✅ 이메일 유효성 검사 (잘못된 형식 거부)
- ✅ 비밀번호 유효성 검사 (최소 8자)
- ✅ 올바른 자격 증명으로 로그인
- ✅ 잘못된 비밀번호로 로그인 (오류 표시)
- ✅ 페이지 새로고침 시 JWT 토큰 지속성
- ✅ 보호된 라우트 접근 제어

테스트 실행 중... 7개 테스트 모두 통과 ✅
─────────────────────────────────────────────────────────

사용자: "/security-review"

Claude (/security-review 명령어): [보안 감사]
─────────────────────────────────────────────────────────
보안 감사 결과:

✅ 통과:
- bcrypt로 비밀번호 해싱 (10 라운드)
- JWT가 httpOnly 쿠키에 저장됨
- Zod로 입력 유효성 검사
- 하드코딩된 시크릿 없음 (env 변수 사용)
- SQL 인젝션 방지 (매개변수화된 쿼리)
- XSS 보호 (출력 이스케이프)

⚠️ 경고:
1. 로그인 엔드포인트에 속도 제한
   → 추가: IP당 15분에 5회 시도
   → 무차별 대입 공격 방지

2. 상태 변경 요청을 위한 CSRF 보호
   → 추가: 로그인/등록을 위한 CSRF 토큰
   → 크로스 사이트 요청 위조 방지

3. 고가치 계정에 2FA 추가 고려
   → 선택 사항: TOTP 기반 2FA
   → 관리자 계정의 보안 강화
─────────────────────────────────────────────────────────

사용자: "경고 수정한 다음, /test-and-build"

Claude: [속도 제한 및 CSRF 보호 추가]
→ express-rate-limit 설치됨
→ 속도 제한 미들웨어 추가 (15분에 5회 시도)
→ csurf 설치됨
→ 폼에 CSRF 토큰 추가

[/test-and-build 실행]
→ 모든 테스트 통과 ✅
→ 빌드 성공 ✅
→ 타입 오류 없음 ✅
→ ESLint 통과 ✅

사용자: "/commit-push-pr"

Claude: [커밋 및 PR 생성]
─────────────────────────────────────────────────────────
✅ 커밋 생성됨:
   feat: add user authentication with JWT tokens

✅ 푸시됨: feature/user-authentication

✅ 풀 리퀘스트 생성됨: #42
   제목: feat: add user authentication with JWT tokens

   ## 요약
   - 이메일/비밀번호 인증 구현
   - JWT 토큰 기반 세션 관리
   - 속도 제한 및 CSRF 보호
   - 종합적인 E2E 테스트 커버리지

   ## 테스트 계획
   - [x] 유효한 데이터로 사용자 등록
   - [x] 이메일/비밀번호 유효성 검사
   - [x] 로그인/로그아웃 플로우
   - [x] 보호된 라우트 접근 제어
   - [x] 보안 감사 통과
   - [x] 모든 테스트 통과
   - [x] 빌드 성공

   🤖 [Claude Code](https://claude.com/claude-code)로 생성됨
─────────────────────────────────────────────────────────

총 소요 시간: 약 30분
품질: 보안이 내장된 프로덕션 준비 완료
커버리지: 95% 테스트 커버리지, 모든 엣지 케이스 처리됨
```

### 3.3 버그 수정 워크플로우

**간단한 버그** (알려진 수정):

```
1. 문제 식별
2. 수정 구현
3. /test-and-build (회귀 없음 확인)
4. /commit-push-pr
```

**복잡한 버그** (조사 필요):

```
1. 버그 재현
2. 근본 원인 조사
3. [Shift+Tab 두 번] 수정 계획 생성
4. 수정 구현
5. verify-app 에이전트에 위임 (버그가 실제로 수정되었는지 확인)
6. /test-and-build
7. /commit-push-pr
```

**예제 - 타임존 버그 수정:**

```
사용자: "사용자가 다른 타임존에 있을 때 날짜 선택기가 잘못된 날짜를 표시합니다"

Claude: [조사]
→ 날짜 선택기 컴포넌트 읽기
→ 문제 발견: UTC 대신 new Date() 사용
→ 근본 원인: 사용자 타임존 설정 무시

[Shift+Tab 두 번] 수정 계획 생성:
1. 데이터베이스에 날짜를 UTC로 저장
2. 프론트엔드에서 사용자 타임존으로 변환
3. 사용자 설정에 타임존 선택기 추가
4. 날짜 선택기가 사용자 타임존을 사용하도록 업데이트
5. 여러 타임존에 대한 테스트 추가

사용자: "승인합니다"

Claude: [수정 구현]

verify-app 에이전트:
→ 여러 타임존으로 테스트 (US/Pacific, US/Eastern, Europe/London, Asia/Tokyo)
→ 모든 타임존에서 날짜가 올바르게 표시되는지 확인
→ ✅ 버그 수정됨

/test-and-build
→ 모든 테스트 통과 ✅

/commit-push-pr
→ fix: respect user timezone in date picker
```

### 3.4 레거시 코드 리팩토링

```
1단계: 테스트가 있는지 확인
/test-coverage [경로]
→ 커버리지 <80%인 경우, 먼저 테스트를 작성하세요
→ 테스트는 리팩토링 중 안전망입니다

2단계: 리팩토링 전략 생성
/plan "리팩토링 [모듈 이름]"
→ planner 에이전트가 전략을 생성합니다
→ 추출할 패턴을 식별합니다
→ 점진적 단계를 계획합니다

3단계: 코드 현대화
refactor-cleaner 에이전트에 위임
→ 체계적인 현대화
→ 죽은 코드 제거
→ 최신 패턴으로 업데이트
→ 가독성 향상

4단계: 로직 단순화
code-simplifier 에이전트에 위임
→ 과도한 엔지니어링 제거
→ 한 번만 사용되는 함수 인라인화
→ 복잡성 감소
→ 성능 향상

5단계: 손상 없음 확인
/test-and-build
→ 리팩토링이 아무것도 손상시키지 않았는지 확인
→ 모든 테스트가 여전히 통과

6단계: 코드 리뷰
/review-changes
→ 리팩토링 품질 확인
→ 개선 사항 확인

7단계: 커밋
/commit-push-pr
→ refactor: modernize [모듈 이름]
```

### 3.5 프로덕션 인시던트 대응

```
1단계: 인시던트 이해
→ 오류 로그 검토
→ 영향 및 심각도 식별
→ 가능하면 재현

2단계: 대응 계획 생성
[Shift+Tab 두 번]
→ planner 에이전트가 인시던트 대응 계획을 생성합니다
→ 영향별로 수정 우선순위 지정
→ 빠른 해결책 대 장기 수정 식별

3단계: 핫픽스 구현
→ 중요한 문제의 경우, 필요하면 일반 워크플로우 우회
→ 먼저 출혈 중단에 집중

4단계: 수정 확인
verify-app 에이전트에 위임
→ 스테이징에서 즉시 수정 테스트
→ 인시던트 해결 확인

5단계: 품질 확인
/test-and-build
→ 핫픽스라도 테스트 통과 확인
→ 회귀 도입되지 않음

6단계: 배포
/commit-push-pr
→ 커밋에 "hotfix:" 접두사 사용
→ 즉시 프로덕션에 배포

7단계: 사후 검토
→ 배운 교훈으로 CLAUDE.md 업데이트
→ 무엇이 잘못되었는지 문서화
→ 예방 조치 추가
→ 모니터링/알림 개선
```

### 3.6 코드 리뷰 및 릴리스 전 워크플로우

**모든 PR 전** (필수):

```
1. /security-review
   → 보안 감사
   → OWASP 검사
   → 시크릿 탐지

2. /review-changes
   → 코드 품질 리뷰
   → 모범 사례 확인
   → 패턴 준수

3. /test-coverage
   → 적절한 테스트 확인
   → 최소 80% 커버리지
   → 중요 경로 테스트됨

4. /test-and-build
   → 모든 테스트 통과
   → 빌드 성공
   → 린터 오류 없음

5. verify-app 에이전트에 위임
   → 엔드투엔드 검증
   → 통합 테스트
   → 사용자 워크플로우 검증

그다음:
6. /commit-push-pr
   → 풀 리퀘스트 생성
   → 테스트 계획 포함
   → 리뷰어 태그
```

---

## 4. 에이전트 오케스트레이션

### 4.1 하이브리드 에이전트 모델

**핵심 철학**: 메인 에이전트는 표준 작업을 직접 코딩하고, 전문성이 필요한 경우 전문가에게 위임합니다.

**메인 에이전트가 직접 처리하는 작업**:
- 표준 CRUD 작업
- 간단한 버그 수정 (< 3개 파일)
- 기본 리팩토링
- 문서 업데이트
- 간단한 기능 구현 (컴포넌트, 라우트, 서비스)
- Git 작업 (커밋, 푸시, PR)
- 템플릿 사용 및 패턴 따르기

**전문가에게 위임해야 하는 경우**:
- 복잡한 아키텍처 필요 → `architect`, `planner`
- 특수 도메인 → `auth-specialist`, `database-architect`, `api-designer`, `graphql-specialist`, `websocket-specialist`
- 보안이 중요한 작업 → `security-reviewer`
- 테스트 전략 → `tdd-guide`, `unit-test-writer`, `e2e-runner`
- 성능 최적화 → `performance-optimizer`
- 운영 작업 → `ci-cd-specialist`, `docker-specialist`, `migration-specialist`
- 코드 품질 리뷰 → `code-reviewer`, `security-reviewer`
- 접근성 준수 → `accessibility-auditor`
- 대규모 리팩토링 (>5개 파일) → `refactor-cleaner`

### 4.2 순차적 패턴

**패턴 1: 간단한 기능 (메인 에이전트만 사용)**

```
1. 메인 에이전트가 요구사항 분석
   → 컨텍스트 이해
   → 변경할 파일 식별

2. 메인 에이전트가 직접 구현
   → 코드 + 테스트 작성
   → 프로젝트 패턴 따르기
   → 템플릿 사용

3. 메인 에이전트가 자체 검증
   → 테스트 실행
   → lint/build 확인
   → 선택사항: 복잡한 경우 code-reviewer에 위임

4. 메인 에이전트가 커밋
   → /commit-push-pr
```

**패턴 2: 복잡한 기능 (전문가 사용)**

```
1. 선택사항: planner 에이전트에 위임 (복잡한 경우)
   → 상세한 구현 계획 생성
   → 의존성 식별
   → 테스트 전략 제안

2. 메인 에이전트 OR 전문가가 구현
   → 표준 작업: 메인 에이전트가 직접 코딩
   → 특수 작업: 도메인 전문가에게 위임
   → 계획을 단계별로 따름

3. code-simplifier 에이전트에 위임 (선택사항)
   → 과도한 엔지니어링 제거
   → 복잡한 로직 단순화
   → 가독성 향상

4. verify-app 에이전트에 위임 (선택사항)
   → 엔드투엔드 검증
   → 통합 테스트
   → 사용자 워크플로우 검증
```

**패턴 3: 리팩토링 → 테스트 → 문서화**

```
1. 작은 리팩토링: 메인 에이전트가 직접 처리
   큰 리팩토링 (>5개 파일): refactor-cleaner 에이전트에 위임
   → 레거시 코드 현대화
   → 죽은 코드 제거
   → 패턴 업데이트

2. tdd-guide OR unit-test-writer 에이전트에 위임
   → 누락된 테스트 추가
   → 커버리지 확보
   → 엣지 케이스 테스트

3. 간단한 문서: 메인 에이전트가 직접 업데이트
   포괄적인 문서: doc-updater 에이전트에 위임
   → 코드와 문서 동기화
   → API 문서 업데이트
   → 예제 새로고침
```

**패턴 4: 빌드 → 수정 → 검증**

```
1. 메인 에이전트가 /build-fix 명령어 실행
   → 빌드 오류 자동 수정
   → 타입 오류 처리
   → import 수정

2. (복잡한 빌드 문제인 경우)
   build-error-resolver 에이전트에 위임
   → 체계적인 오류 수정
   → 영향별 우선순위 지정

3. 메인 에이전트가 /test-and-build 실행
   → 종합적 검증
   → 모든 것이 작동하는지 확인
```

### 4.3 병렬 에이전트 패턴

**단일 세션 내에서** (대부분의 작업에 권장):
메인 에이전트는 단일 메시지에서 여러 Task 도구 호출로 여러 전문가에게 병렬 위임할 수 있습니다:

```
메인 에이전트가 병렬로 위임:
- security-reviewer 에이전트 (백그라운드 감사)
- code-reviewer 에이전트 (코드 품질)
- doc-updater 에이전트 (문서 업데이트)

모든 결과가 메인 에이전트로 돌아와 검토됩니다
```

**여러 세션** (큰 독립적인 작업을 위해):
필요한 경우 병렬 Claude Code 세션을 실행:

```
터미널 1 (메인): 메인 에이전트가 기능 A 구현
터미널 2: 메인 에이전트가 기능 B 구현
터미널 3: security-reviewer 에이전트에 위임 (포괄적 감사)
터미널 4: e2e-runner 에이전트에 위임 (전체 테스트 스위트 생성)
터미널 5: /test-and-build 실행 (지속적 테스트)
```

**병렬 실행의 이점**:
- ✅ 더 빠른 전체 완료 (작업이 동시에 진행됨)
- ✅ 독립적인 컨텍스트 (작업 간 컨텍스트 오염 없음)
- ✅ 에이전트별 전문화된 집중 (각 에이전트가 자신의 도메인에서 작업)
- ✅ 더 나은 리소스 활용 (Claude 사용 극대화)

**병렬 실행을 사용해야 할 때**:
- 독립적인 측면이 있는 대규모 기능
- 여러 리뷰가 필요한 경우 (보안, 코드 품질, 성능) - 단일 세션 병렬 사용
- 백그라운드 문서 업데이트
- 지속적 테스트 생성
- 완전히 별도의 기능 - 여러 세션 사용

**한계**:
- 권장: 3-5개 병렬 세션 (여러 터미널을 사용하는 경우)
- 최대: 5개 세션 (이 이상은 수익 감소)
- 리뷰 작업의 경우 단일 세션 병렬 위임 선호

### 4.3 에이전트 컨텍스트 관리

**핵심 원칙**: 에이전트는 메인 세션과 분리된 격리된 컨텍스트를 가집니다

**모범 사례**:

1. **명확한 목표 제공**
   ```
   ❌ 나쁨: "auth 코드를 봐주세요"
   ✅ 좋음: "JWT 처리에서 보안 취약점에 대해 src/auth/를 검토하세요"
   ```

2. **집중할 파일 지정**
   ```
   ❌ 나쁨: "코드베이스를 리팩토링하세요"
   ✅ 좋음: "리포지토리 패턴을 사용하도록 src/services/UserService.ts를 리팩토링하세요"
   ```

3. **에이전트 컨텍스트에 과부하 주지 마세요**
   ```
   ❌ 나쁨: "src/의 50개 파일을 모두 읽고 분석하세요"
   ✅ 좋음: "3개의 인증 파일을 분석하세요: auth.ts, jwt.ts, middleware.ts"
   ```

4. **적용 전에 에이전트 출력 검토**
   ```
   → 에이전트가 발견 사항/제안 사항을 반환합니다
   → 메인 컨텍스트에서 검토합니다
   → 무엇을 적용할지 결정합니다
   → 최종 변경 사항을 만듭니다
   ```

**에이전트 위임 임계값**:
- <5개 파일: 메인 컨텍스트에서 작업
- 5-10개 파일: 에이전트에 위임 고려
- >10개 파일: 에이전트에 위임 필수 (컨텍스트 비대화 방지)

---

## 5. MCP 서버 통합

### 5.1 MCP 서버란?

Model Context Protocol(MCP) 서버는 외부 도구 통합을 제공합니다:

**사용 가능한 통합:**
- **filesystem**: 파일 작업 (항상 활성화)
- **github**: GitHub API 작업 (이슈, PR, 커밋)
- **postgres/sqlite**: 데이터베이스 쿼리 및 마이그레이션
- **vercel/railway**: 호스팅 플랫폼에 배포
- **slack**: 팀 커뮤니케이션 및 알림
- **memory**: Claude 세션 간 영구 메모리
- **sequential-thinking**: 복잡한 문제를 위한 향상된 추론
- **brave-search**: 웹 검색 기능
- **google-maps**: 위치 및 지도 서비스
- **firecrawl**: 웹 스크래핑 및 크롤링
- **cloudflare**: CDN, workers, 관찰 가능성
- **clickhouse**: 분석 데이터베이스 쿼리
- **context7**: 컨텍스트 관리 도구
- **magic**: 추가 유틸리티

**현재 구성**: `.mcp.template.json`에 27개의 사전 구성된 서버, 성능을 위해 대부분 기본적으로 비활성화됨. 필요한 것만 활성화하세요.

### 5.2 MCP 서버 활성화

**1단계: 현재 구성 확인**

```bash
# 활성화된 MCP 확인
grep '"disabled": false' .mcp.json
```

**2단계: API 자격 증명 추가** (필요한 경우)

```bash
# .env 파일 또는 환경 변수에서
export GITHUB_PERSONAL_ACCESS_TOKEN="ghp_xxxxx"
export POSTGRES_URL="postgresql://localhost/mydb"
export VERCEL_API_TOKEN="your_token_here"
```

**3단계: .mcp.json에서 활성화**

```json
// 활성화할 서버 찾기
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "YOUR_GITHUB_TOKEN_HERE"
      },
      "disabled": false  // ← true에서 false로 변경
    }
  }
}
```

**4단계: Claude Code 세션 재시작**

MCP는 Claude Code가 시작될 때 로드됩니다. 변경 사항을 적용하려면 세션을 재시작하세요.

### 5.3 MCP 서버 사용 패턴

**GitHub 통합**:
```
활성화: github MCP 서버
용도:
→ 코드 TODO에서 이슈 생성
→ 풀 리퀘스트에 댓글 달기
→ 리포지토리 검색
→ 커밋 이력 가져오기
→ 프로젝트 보드 관리
```

**데이터베이스 통합**:
```
활성화: postgres 또는 sqlite MCP 서버
용도:
→ 데이터베이스에 직접 쿼리
→ 스키마 검사
→ 마이그레이션 생성
→ 테스트 데이터 설정
→ 성능 분석
```

**배포 통합**:
```
활성화: vercel 또는 railway MCP 서버
용도:
→ 프로덕션에 배포
→ 배포 상태 확인
→ 배포 로그 보기
→ 잘못된 배포 롤백
→ 환경 변수 관리
```

**검색 통합**:
```
활성화: brave-search MCP 서버
용도:
→ 문서 조사
→ 코드 예제 찾기
→ API 참조 확인
→ 새 라이브러리 학습
```

### 5.4 MCP를 통한 컨텍스트 관리

**중요 경고**: 너무 많은 활성화된 MCP는 성능을 심각하게 저하시킵니다.

**200k → 70k 문제**:
- 시작 컨텍스트 윈도우: 200k 토큰
- 10개 MCP + 20개 도구 활성화 시: 약 70k로 감소
- 결과: 느린 응답 (>10초), 불완전한 답변, 세션 충돌

**성능 가이드라인**:

```bash
# 활성화된 MCP 개수 확인
grep '"disabled": false' .mcp.json | wc -l

# 최적 성능을 위해 10개 미만이어야 함
```

**프로젝트별 비활성화**:

```json
// .claude/settings.local.json
{
  "disabledMcpServers": [
    "slack",           // 이 프로젝트에서 Slack 미사용
    "google-maps",     // 지도 미사용
    "cloudflare-docs"  // Cloudflare에 배포하지 않음
  ]
}
```

**모범 사례**:
- 적극적으로 사용하는 MCP만 활성화
- 통합 사용이 끝나면 MCP 비활성화
- 총 활성화 개수를 10개 미만으로 유지
- 응답 시간 모니터링 (>5초 = MCP가 너무 많음)

---

## 6. 성능 및 최적화

### 6.1 컨텍스트 윈도우 관리

전체 세부사항은 `.claude/rules/essential-rules.md`를 참조하세요.

**하드 리미트** (실전 테스트된 임계값):
- **활성화된 MCP**: 프로젝트당 10개 미만
- **활성 도구**: 총 80개 미만
- **세션당 읽은 파일**: 50개 미만
- **목표 컨텍스트 사용량**: 60-80k 토큰 (>120k는 안 됨)

**성능 경고 신호**:
- ⚠️ 응답 시간 >10초
- ⚠️ 불완전한 응답 또는 중간에 끊김
- ⚠️ Claude가 "간략하게 해야 합니다"라고 말함
- ⚠️ 세션 충돌 또는 타임아웃

**최적화 전략**:

1. **사용하지 않는 MCP 비활성화**
   ```bash
   # 개수 확인
   grep '"disabled": false' .mcp.json | wc -l

   # 사용하지 않으면 비활성화
   # .mcp.json을 편집하고 "disabled": true로 설정
   ```

2. **무거운 작업을 에이전트에 위임**
   ```
   ❌ 나쁨: 메인 컨텍스트에서 50개 파일 읽기
   ✅ 좋음: 격리된 컨텍스트를 가진 에이전트에 위임
   ```

3. **규칙/스킬을 간결하게 유지**
   ```
   규칙: 각각 500줄 미만
   스킬: 각각 800줄 미만
   오래된 콘텐츠 제거
   ```

4. **정기적으로 새 세션 시작**
   ```
   컨텍스트가 무거워질 때 (느린 응답):
   → 작업 저장
   → 새 Claude Code 세션 시작
   → 새로운 컨텍스트로 계속
   ```

### 6.2 모델 선택 전략

**Haiku** ($) - 빠르고 저렴함:
- 코드 포맷팅 (Prettier, ESLint)
- 간단한 한 줄 수정
- 테스트 실행
- 빠른 리팩토링 (<10줄)
- 반복 작업

**Sonnet** ($$) - 균형 잡힘 (기본값):
- 기능 구현
- 버그 수정
- 코드 리뷰
- 테스트 작성
- 대부분의 개발 작업
- 일반 리팩토링

**Opus** ($$$) - 강력하고 비쌈:
- 복잡한 아키텍처 설계
- 중요한 보안 결정
- 프로덕션 인시던트 대응
- 대규모 리팩토링 (>500줄)
- 시스템 설계 논의

**모델 전환**:

```json
// .claude/settings.json에서
{
  "model": "haiku"   // 또는 "sonnet" 또는 "opus"
}
```

**비용-편익 분석**:
- Haiku: 빠르지만 더 많은 왕복이 필요할 수 있음
- Sonnet: 균형 잡힘, 90%의 작업에 적합
- Opus: 느리지만 복잡한 작업에서 첫 번째 시도에 올바름

### 6.3 병렬 세션

더 빠른 완료를 위해 여러 Claude Code 세션을 동시에 실행:

**설정**:
```
터미널/VSCode 창 1: 메인 개발 작업
터미널/VSCode 창 2: 보안 감사 (security-reviewer 에이전트)
터미널/VSCode 창 3: 테스트 생성 (e2e-runner 에이전트)
터미널/VSCode 창 4: 문서화 (doc-updater 에이전트)
터미널/VSCode 창 5: 코드 리뷰 (/review-changes)
```

**이점**:
- ✅ 각 세션이 전체 200k 컨텍스트 윈도우를 가짐
- ✅ 세션 간 컨텍스트 오염 없음
- ✅ 더 빠른 전체 완료 (병렬 작업)
- ✅ 더 나은 집중 (각 세션이 하나의 작업을 수행)

**권장 한계**:
- 2-3개 세션으로 시작
- 대규모 기능의 경우 최대 5개 세션으로 확장
- 5개 세션 이상: 수익 감소

---

## 7. 커스터마이제이션 로드맵

### 7.1 1주차: 필수 설정

**1-2일차: 초기 구성**

```
1일차:
- [ ] README.md와 CLAUDE.md 읽기
- [ ] git 리포지토리 초기화
- [ ] 첫 명령어 실행: /test-and-build
- [ ] 사용 가능한 명령어 탐색 (/help)

2일차:
- [ ] 플랜 모드 시도 (Shift+Tab 두 번)
- [ ] /commit-push-pr 워크플로우 테스트
- [ ] GitHub 사용 시 github MCP 활성화
```

**3-4일차: CLAUDE.md 커스터마이즈**

```
3일차:
- [ ] CLAUDE.md에 기술 스택 문서화
- [ ] 팀 명명 규칙 추가
- [ ] 프로젝트 의존성 나열

4일차:
- [ ] CLAUDE.md에 첫 번째 일반적인 실수 문서화
- [ ] 프로젝트별 패턴 추가
- [ ] 코드 리뷰 체크리스트 설정
```

**5-7일차: 필수 MCP 활성화**

```
5일차:
- [ ] 데이터베이스 MCP 활성화 (postgres 또는 sqlite)
- [ ] 데이터베이스 쿼리 테스트

6일차:
- [ ] 배포 MCP 활성화 (vercel 또는 railway)
- [ ] 배포 워크플로우 테스트

7일차:
- [ ] 활성화된 MCP 검토 (10개 미만이어야 함)
- [ ] 통합이 올바르게 작동하는지 테스트
```

### 7.2 첫 달: 파워 유저

**2주차: 명령어 마스터**

```
- [ ] 10개 명령어 모두 최소 한 번 사용
- [ ] 여러 명령어를 결합한 워크플로우 생성
- [ ] 프로젝트에 대한 사전 승인 작업 설정
- [ ] 워크플로우에 맞게 훅 커스터마이즈
```

**3주차: 에이전트 숙달**

```
- [ ] 각 에이전트 유형에 위임
- [ ] 순차적 에이전트 워크플로우 생성 (계획 → 구현 → 단순화 → 검증)
- [ ] 병렬 에이전트 세션 시도 (2-3개 터미널)
- [ ] 에이전트 사용 대 직접 구현 시기 이해
```

**4주차: 품질 자동화**

```
- [ ] 프리 커밋 훅 설정
- [ ] 환경별 설정 구성 (개발/운영)
- [ ] CI/CD 파이프라인과 통합
- [ ] 팀 코드 리뷰 워크플로우 확립
```

### 7.3 지속적: 복합적 개선

**월간 작업**:
```
- [ ] CLAUDE.md 검토 및 업데이트
- [ ] 새로 발견된 실수 추가
- [ ] 코드베이스가 발전함에 따라 패턴 업데이트
- [ ] 팀과 개선 사항 공유
- [ ] 활성화된 MCP 검토 및 최적화
```

**분기별 작업**:
```
- [ ] 반복 작업을 위한 커스텀 에이전트 생성
- [ ] 팀 워크플로우를 위한 커스텀 명령어 구축
- [ ] 추가할 새 MCP 평가
- [ ] 유용한 패턴을 커뮤니티에 기여 (선택 사항)
```

### 7.4 커스텀 명령어 만들기

**템플릿**:

```markdown
# 내 커스텀 명령어

[이 명령어가 수행하는 작업에 대한 한 줄 설명]

## 사용법

이 명령어를 언제 사용하고 무엇을 달성하는지.

## 지침

1. Claude가 따를 단계별 지침
2. 구체적이고 실행 가능하게
3. 오류 처리 포함
4. 필요에 따라 스킬/규칙 참조

## 예제

입력과 예상 출력을 보여주는 구체적인 사용 예제.
```

**저장 위치**: `.claude/commands/my-command.md`

### 7.5 커스텀 에이전트 만들기

**템플릿**:

```markdown
# 내 커스텀 에이전트

[에이전트의 전문 분야에 대한 한 줄 설명]

## 전제 조건

- [필요한 도구 또는 설정]
- [필요한 의존성]

## 지침

이 전문 작업에 대한 상세한 단계별 지침.
포함 사항:
- 분석할 내용
- 찾아야 할 내용
- 보고할 내용
- 사용할 형식

## 사용 예제

"[특정 작업]을 위해 my-agent 에이전트에 위임"

예상 출력 형식 및 결과.
```

**저장 위치**: `.claude/agents/my-agent.md`

---

## 8. 팀 협업

### 8.1 공유 CLAUDE.md

**모범 사례**: 프로젝트당 하나의 CLAUDE.md, 버전 관리에 커밋됨

**구조**:

```markdown
## 목적
이 파일이 존재하는 이유와 사용 방법

## 기술 스택
버전이 포함된 완전한 기술 스택

## 일반적인 실수
시간이 지남에 따라 발견된 팀별 주의사항
- 실수가 발생할 때마다 이 섹션에 추가
- 무엇이 잘못되었고 올바른 접근 방식은 무엇인지 포함

## 프로젝트별 패턴
이 프로젝트에 특정한 패턴
- API 응답 형식
- 오류 처리 접근 방식
- 데이터베이스 접근 패턴
- 인증 플로우
```

**업데이트 빈도**: 모든 실수나 배운 교훈 후

**팀 워크플로우**:
```
1. 개발자가 실수를 함
2. 실수를 수정함
3. CLAUDE.md에 문서화함
4. CLAUDE.md 업데이트를 커밋함
5. 팀이 공유 지식으로부터 혜택을 받음
```

### 8.2 코드 리뷰 통합

**Claude Code를 사용한 리뷰어 워크플로우**:

```
1. 리뷰할 브랜치 가져오기
2. Claude에게 요청: "이 PR 리뷰: [PR URL 또는 설명]"
3. Claude 분석:
   → 변경된 모든 파일
   → 프로젝트 규칙에 대한 검사
   → 테스트 커버리지 확인
   → 잠재적 문제 식별
4. Claude의 발견 사항 검토
5. 자신의 관찰 추가
6. PR 작성자에게 피드백 제공
```

**PR 제출 전** (작성자):

```
/security-review      # 보안 감사
/review-changes       # 코드 품질 리뷰
/test-and-build       # 테스트 및 빌드 실행

그다음:
/commit-push-pr       # PR 생성
```

### 8.3 TODO 주석을 통한 비동기 협업

**패턴**: 팀원(또는 미래의 자신)을 위한 TODO 주석 남기기

```typescript
// TODO(@teammate): 이것은 엣지 케이스 X에 대한 오류 처리가 필요합니다
// 우리의 표준 접근 방식은 CLAUDE.md의 오류 패턴 섹션을 참조하세요

// TODO(@me): API가 안정화되면 이것을 리팩토링하세요
// 현재 3가지 다른 응답 형식을 처리 중

// TODO: 여기에 속도 제한을 추가하세요
// 우리의 속도 제한 패턴은 security.md 규칙을 참조하세요
```

Claude Code는:
- TODO 주석 탐지
- 이에 대해 상기시킴
- 요청 시 해결 지원
- CLAUDE.md 패턴을 기반으로 구현 제안

---

## 9. 문제 해결

### 9.1 일반적인 문제

**문제: "응답이 느림 (>10초)"**

**진단**: 너무 많은 활성화된 MCP 또는 비대해진 컨텍스트

**해결책**:
```bash
# 활성화된 MCP 확인
grep '"disabled": false' .mcp.json | wc -l

# 10개 미만이어야 함
# 더 많으면 .mcp.json을 편집하여 사용하지 않는 것들을 비활성화
```

**문제: "에이전트가 예상대로 작동하지 않음"**

**진단**: 불명확한 위임 또는 잘못된 에이전트 선택

**해결책**:
```
❌ 나쁨: "refactor-cleaner를 사용하세요"
✅ 좋음: "src/auth/ 디렉토리를 현대화하기 위해 refactor-cleaner 에이전트에 위임하세요"

❌ 나쁨: "에이전트가 이것을 봐주세요"
✅ 좋음: "인증 플로우에서 OWASP Top 10 취약점을 스캔하기 위해 security-reviewer 에이전트에 위임하세요"
```

**문제: "명령어를 찾을 수 없음"**

**진단**: 명령어 파일이 누락되었거나 잘못 명명됨

**해결책**:
```bash
# 명령어가 존재하는지 확인
ls .claude/commands/

# 명명 규칙 확인:
# 명령어: /test-and-build
# 파일: test-and-build.md (정확히 일치)
```

**문제: "훅이 작업을 차단함"**

**진단**: 훅이 너무 오래 걸리거나 실패함

**해결책**:
```bash
# 일시적으로 훅 비활성화
# .claude/settings.json 편집
{
  "hooks": []  // 빈 배열은 모든 훅을 비활성화함
}

# 또는 특정 훅 수정:
# 훅은 100ms 미만에 완료되어야 함
# 차단 방지를 위해 || true 추가:
"command": "your-command || true"
```

**문제: "MCP 서버가 연결되지 않음"**

**진단**: 비활성화됨, 자격 증명 누락 또는 네트워크 문제

**해결책**:
```bash
# 1. 활성화 확인
# .mcp.json에서: "disabled": false

# 2. 자격 증명 확인
# 환경 변수가 올바르게 설정되었는지 확인

# 3. MCP를 직접 테스트
npx @modelcontextprotocol/server-github

# 4. 네트워크 확인
# 일부 MCP는 인터넷 액세스 필요

# 5. Claude Code 재시작
# MCP는 세션 시작 시 로드됨
```

### 9.2 도움 받기

**셀프 서비스**:
1. 이 WORKFLOW.md 확인
2. [README.md](README.md) 검토
3. `.claude/rules/`의 관련 규칙 파일 읽기
4. 프로젝트별 안내는 CLAUDE.md 검색
5. `.claude/skills/`의 스킬 파일 확인
6. `.claude/agents/INDEX.md`의 에이전트 인덱스 확인

**커뮤니티 지원**:
1. 기존 GitHub 이슈 검색
2. 다음을 포함한 새 이슈 열기:
   - 문제에 대한 명확한 설명
   - 재현 단계
   - 예상 대 실제 동작
   - 환경 세부 정보 (OS, Claude Code 버전)

---

## 10. 고급 주제

### 10.1 훅 커스터마이제이션

`.claude/settings.json`에서 훅을 구성하세요 - `hooks` 섹션을 참조하세요.

**프리 툴 훅** (작업 전 경고):

```json
{
  "when": "PreToolUse",
  "matcher": "tool == \"Write\" && tool_input.file_path matches \"\\\\.tsx?$\"",
  "hooks": [{
    "type": "command",
    "command": "grep -n 'console\\.log' \"$file_path\" 2>/dev/null && echo '[Hook] 경고: console.log 탐지됨' >&2 || true"
  }]
}
```

**포스트 툴 훅** (작업 후 자동 포맷팅):

```json
{
  "when": "PostToolUse",
  "matcher": "tool in [\"Edit\", \"Write\"] && tool_input.file_path matches \"\\\\.tsx?$\"",
  "hooks": [{
    "type": "command",
    "command": "npx prettier --write \"$file_path\" 2>&1 | head -1"
  }]
}
```

**성능 요구사항**: 훅은 100ms 미만에 완료되어야 합니다

### 10.2 환경별 워크플로우

**개발** (`settings.dev.json`):
- Sonnet 모델 (더 빠르고 저렴함)
- 자동 수락 활성화 (안전성보다 속도)
- 모든 작업 허용 (최대 자유)
- 허용적 훅

**프로덕션** (`settings.prod.json`):
- Opus 모델 (최고 품질)
- 자동 수락 비활성화 (안전 우선)
- 읽기 전용 작업만 (실수로 변경하지 않음)
- 엄격한 훅

**환경 전환**:

```bash
# 개발로 전환
cp .claude/settings.dev.json .claude/settings.json

# 프로덕션으로 전환
cp .claude/settings.prod.json .claude/settings.json
```

### 10.3 사전 승인된 작업

사용자 확인이 필요 없는 작업 구성:

```json
{
  "allowedPrompts": [
    {"tool": "Bash", "prompt": "run tests"},
    {"tool": "Bash", "prompt": "run build"},
    {"tool": "Bash", "prompt": "format code"},
    {"tool": "Bash", "prompt": "run linter"},
    {"tool": "Bash", "prompt": "install dependencies"}
  ]
}
```

**이점**:
- ✅ 더 빠른 워크플로우 (권한 프롬프트 없음)
- ✅ 더 적은 중단 (자동 승인)
- ✅ 더 나은 자동화 (지속적 작업)

**보안 고려사항**:
- ⚠️ 읽기 전용 및 안전한 작업만 사전 승인
- ⚠️ 사전 승인하지 않을 것: 파괴적 작업, 배포, 데이터베이스 쓰기
- ⚠️ 코드베이스가 발전함에 따라 정기적으로 검토

---

## 빠른 참조

### 가장 많이 사용하는 명령어 (매일)

```bash
/commit-push-pr      # 커밋 생성, 푸시 및 PR
/test-and-build      # 테스트 및 빌드 실행, 오류 수정
/review-changes      # 커밋 전 코드 리뷰
/security-review     # 보안 감사
```

### 가장 많이 사용하는 에이전트 (매주)

```bash
planner              # 복잡한 기능 계획
security-reviewer    # 보안 감사
verify-app          # 엔드투엔드 검증
code-simplifier     # 복잡성 제거
```

### 가장 중요한 규칙

```bash
essential-rules.md   # 보안, 테스트, 코딩 표준 (통합됨)
agent-workflow.md    # 위임, 워크플로우, git 표준
```

### 중요한 성능 임계값

```
활성화된 MCP: 10개 미만
활성 도구: 80개 미만
읽은 파일: 세션당 50개 미만
응답 시간: 5초 미만 (>5초 시 경고)
컨텍스트 사용량: 60-80k 목표 (>120k 시 경고)
```

---

## 다음 단계

**신규 사용자**: 프로젝트 개요는 [README.md](README.md)로 시작하세요

**시작하기**: [1주차: 필수 설정](#71-1주차-필수-설정)을 따르세요

**팀 리더**: [팀 협업](#8-팀-협업) 섹션을 읽으세요

**파워 유저**: [고급 주제](#10-고급-주제)를 탐색하고 커스텀 명령어/에이전트를 만드세요

**도움이 필요하신가요?**: [문제 해결](#9-문제-해결)을 확인하거나 이슈를 여세요

---

## 추가 리소스

- **프로젝트 개요**: [README.md](README.md)
- **팀 가이드라인**: [CLAUDE.md](CLAUDE.md)
- **에이전트 디렉토리**: [.claude/agents/INDEX.md](.claude/agents/INDEX.md)
- **스킬 디렉토리**: [.claude/skills/INDEX.md](.claude/skills/INDEX.md)
- **명령어 가이드**: [.claude/commands/README.md](.claude/commands/README.md)
- **체크리스트**: [.claude/checklists/README.md](.claude/checklists/README.md)
- **템플릿**: [.claude/templates/README.md](.claude/templates/README.md)
- **워크플로우**: [.claude/workflows/README.md](.claude/workflows/README.md)

---

**기억하세요**: 이것은 복합적인 시스템입니다. CLAUDE.md에 문서화하는 모든 실수, 추가하는 모든 패턴, 만드는 모든 명령어 - 이 모든 것이 팀을 더 빠르게 하고 코드를 더 좋게 만듭니다. 작게 시작하여 꾸준히 성장하면 생산성이 배가되는 것을 보게 될 것입니다.

**질문이 있으신가요?** 팀도 혜택을 받을 수 있도록 CLAUDE.md에 답변을 업데이트하세요.
