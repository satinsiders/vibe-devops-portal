/**
 * use{{HOOK_NAME}} Hook
 *
 * {{HOOK_DESCRIPTION}}
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   const { data, isLoading, error } = use{{HOOK_NAME}}();
 *
 *   if (isLoading) return <Spinner />;
 *   if (error) return <Error message={error.message} />;
 *
 *   return <div>{data}</div>;
 * }
 * ```
 *
 * Template Placeholders:
 * - {{HOOK_NAME}}: PascalCase hook name without 'use' prefix (e.g., Auth, FormValidation, LocalStorage)
 * - {{HOOK_DESCRIPTION}}: Brief description of hook purpose
 * - {{RETURN_TYPE}}: The type of data returned by the hook
 * - {{DEPENDENCIES}}: Hook dependencies for useEffect/useCallback/useMemo
 */

import {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
  type DependencyList,
} from 'react';

// =============================================================================
// Types
// =============================================================================

/**
 * Return type for use{{HOOK_NAME}} hook
 */
export interface Use{{HOOK_NAME}}Result<T = unknown> {
  /**
   * The data returned by the hook
   */
  data: T | null;
  /**
   * Whether the hook is currently loading/processing
   */
  isLoading: boolean;
  /**
   * Error that occurred (if any)
   */
  error: Error | null;
  /**
   * Re-fetch or retry the operation
   */
  refetch: () => Promise<void>;
  /**
   * Reset the hook to initial state
   */
  reset: () => void;
}

/**
 * Options for use{{HOOK_NAME}} hook
 */
export interface Use{{HOOK_NAME}}Options {
  /**
   * Whether to fetch on mount
   * @default true
   */
  enabled?: boolean;
  /**
   * Callback when operation succeeds
   */
  onSuccess?: (data: unknown) => void;
  /**
   * Callback when operation fails
   */
  onError?: (error: Error) => void;
  /**
   * Refetch interval in milliseconds (0 = disabled)
   * @default 0
   */
  refetchInterval?: number;
}

// =============================================================================
// Hook Implementation
// =============================================================================

/**
 * use{{HOOK_NAME}}
 *
 * {{HOOK_DESCRIPTION}}
 *
 * @param options - Configuration options
 * @returns Hook result with data, loading state, error, and control functions
 */
export function use{{HOOK_NAME}}<T = unknown>(
  options: Use{{HOOK_NAME}}Options = {}
): Use{{HOOK_NAME}}Result<T> {
  const {
    enabled = true,
    onSuccess,
    onError,
    refetchInterval = 0,
  } = options;

  // ---------------------------------------------------------------------------
  // State
  // ---------------------------------------------------------------------------

  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(enabled);
  const [error, setError] = useState<Error | null>(null);

  // Ref to track if component is mounted (prevents state updates after unmount)
  const isMountedRef = useRef<boolean>(true);
  // Ref to store abort controller for cancelling requests
  const abortControllerRef = useRef<AbortController | null>(null);

  // ---------------------------------------------------------------------------
  // Core Logic
  // ---------------------------------------------------------------------------

  /**
   * Fetch/compute the data
   * Replace this with your actual implementation
   */
  const fetchData = useCallback(async (signal?: AbortSignal): Promise<T> => {
    // Example implementation - replace with actual logic
    //
    // const response = await fetch('/api/data', { signal });
    // if (!response.ok) {
    //   throw new Error(`HTTP error! status: ${response.status}`);
    // }
    // return response.json();

    // Placeholder - simulates async operation
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Replace with actual data fetching/computation
    return {} as T;
  }, []); // {{DEPENDENCIES}}

  // ---------------------------------------------------------------------------
  // Actions
  // ---------------------------------------------------------------------------

  /**
   * Execute the fetch operation
   */
  const execute = useCallback(async (): Promise<void> => {
    // Cancel any existing request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // Create new abort controller
    abortControllerRef.current = new AbortController();

    try {
      setIsLoading(true);
      setError(null);

      const result = await fetchData(abortControllerRef.current.signal);

      // Only update state if component is still mounted
      if (isMountedRef.current) {
        setData(result);
        onSuccess?.(result);
      }
    } catch (err) {
      // Ignore abort errors
      if (err instanceof Error && err.name === 'AbortError') {
        return;
      }

      const error = err instanceof Error ? err : new Error('Unknown error');

      if (isMountedRef.current) {
        setError(error);
        onError?.(error);
      }
    } finally {
      if (isMountedRef.current) {
        setIsLoading(false);
      }
    }
  }, [fetchData, onSuccess, onError]);

  /**
   * Refetch data
   */
  const refetch = useCallback(async (): Promise<void> => {
    await execute();
  }, [execute]);

  /**
   * Reset hook to initial state
   */
  const reset = useCallback((): void => {
    // Cancel any pending request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    setData(null);
    setError(null);
    setIsLoading(false);
  }, []);

  // ---------------------------------------------------------------------------
  // Effects
  // ---------------------------------------------------------------------------

  // Initial fetch on mount
  useEffect(() => {
    if (enabled) {
      execute();
    }

    return () => {
      // Cleanup: cancel pending request and mark as unmounted
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      isMountedRef.current = false;
    };
  }, [enabled, execute]);

  // Refetch interval
  useEffect(() => {
    if (!enabled || refetchInterval <= 0) {
      return;
    }

    const intervalId = setInterval(() => {
      execute();
    }, refetchInterval);

    return () => {
      clearInterval(intervalId);
    };
  }, [enabled, refetchInterval, execute]);

  // ---------------------------------------------------------------------------
  // Return
  // ---------------------------------------------------------------------------

  return {
    data,
    isLoading,
    error,
    refetch,
    reset,
  };
}

// =============================================================================
// Utility Hooks (Optional - extend as needed)
// =============================================================================

/**
 * Debounced version of use{{HOOK_NAME}}
 */
export function use{{HOOK_NAME}}Debounced<T = unknown>(
  options: Use{{HOOK_NAME}}Options & { debounceMs?: number } = {}
): Use{{HOOK_NAME}}Result<T> {
  const { debounceMs = 300, ...restOptions } = options;

  // Implementation would add debounce logic
  return use{{HOOK_NAME}}<T>(restOptions);
}

// =============================================================================
// Default Export
// =============================================================================

export default use{{HOOK_NAME}};
