/**
 * Error Handler
 *
 * Centralized error handling for {{APP_NAME}}.
 * Provides consistent error responses, logging, and recovery patterns.
 *
 * @example
 * ```typescript
 * // Express
 * app.use(errorHandler);
 *
 * // Next.js
 * export const GET = withErrorHandler(handler);
 *
 * // Manual usage
 * try {
 *   await riskyOperation();
 * } catch (error) {
 *   throw AppError.from(error);
 * }
 * ```
 *
 * Template Placeholders:
 * - {{APP_NAME}}: Application name for error identification
 */

import type { Request, Response, NextFunction, ErrorRequestHandler } from 'express';
import { NextRequest, NextResponse } from 'next/server';

// =============================================================================
// Error Types
// =============================================================================

/**
 * Standard error codes used across the application
 */
export const ErrorCodes = {
  // Client Errors (4xx)
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  RATE_LIMITED: 'RATE_LIMITED',

  // Server Errors (5xx)
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
  DATABASE_ERROR: 'DATABASE_ERROR',
  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',
} as const;

export type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];

/**
 * Error response structure sent to clients
 */
export interface ErrorResponse {
  error: {
    code: ErrorCode | string;
    message: string;
    details?: unknown;
    requestId?: string;
    timestamp?: string;
  };
}

// =============================================================================
// Base Error Class
// =============================================================================

/**
 * Base application error class
 *
 * All custom errors should extend this class to ensure consistent
 * error handling and response formatting.
 */
export class AppError extends Error {
  public readonly code: ErrorCode | string;
  public readonly statusCode: number;
  public readonly details?: unknown;
  public readonly isOperational: boolean;

  constructor(
    message: string,
    code: ErrorCode | string = ErrorCodes.INTERNAL_ERROR,
    statusCode: number = 500,
    details?: unknown
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
    this.isOperational = true; // Distinguishes from programming errors

    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * Convert error to API response format
   */
  toJSON(requestId?: string): ErrorResponse {
    return {
      error: {
        code: this.code,
        message: this.message,
        details: this.details,
        requestId,
        timestamp: new Date().toISOString(),
      },
    };
  }

  /**
   * Create AppError from any error
   */
  static from(error: unknown): AppError {
    if (error instanceof AppError) {
      return error;
    }

    if (error instanceof Error) {
      return new AppError(
        error.message,
        ErrorCodes.INTERNAL_ERROR,
        500,
        { originalError: error.name }
      );
    }

    return new AppError(
      String(error),
      ErrorCodes.INTERNAL_ERROR,
      500
    );
  }
}

// =============================================================================
// Specific Error Classes
// =============================================================================

/**
 * Validation error (400)
 */
export class ValidationError extends AppError {
  constructor(message: string, details?: Record<string, string[]>) {
    super(message, ErrorCodes.VALIDATION_ERROR, 400, details);
  }

  static fromZod(zodError: { issues: Array<{ path: (string | number)[]; message: string }> }): ValidationError {
    const details: Record<string, string[]> = {};
    for (const issue of zodError.issues) {
      const path = issue.path.join('.');
      if (!details[path]) details[path] = [];
      details[path].push(issue.message);
    }
    return new ValidationError('Validation failed', details);
  }
}

/**
 * Authentication error (401)
 */
export class UnauthorizedError extends AppError {
  constructor(message: string = 'Authentication required') {
    super(message, ErrorCodes.UNAUTHORIZED, 401);
  }
}

/**
 * Authorization error (403)
 */
export class ForbiddenError extends AppError {
  constructor(message: string = 'Insufficient permissions') {
    super(message, ErrorCodes.FORBIDDEN, 403);
  }
}

/**
 * Resource not found error (404)
 */
export class NotFoundError extends AppError {
  constructor(resource: string, id?: string) {
    const message = id
      ? `${resource} with ID ${id} not found`
      : `${resource} not found`;
    super(message, ErrorCodes.NOT_FOUND, 404);
  }
}

/**
 * Conflict error (409)
 */
export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, ErrorCodes.CONFLICT, 409);
  }
}

/**
 * Rate limit error (429)
 */
export class RateLimitError extends AppError {
  constructor(retryAfter?: number) {
    super(
      'Too many requests. Please try again later.',
      ErrorCodes.RATE_LIMITED,
      429,
      retryAfter ? { retryAfter } : undefined
    );
  }
}

/**
 * Database error (500)
 */
export class DatabaseError extends AppError {
  constructor(message: string = 'Database operation failed') {
    super(message, ErrorCodes.DATABASE_ERROR, 500);
  }
}

/**
 * External service error (502)
 */
export class ExternalServiceError extends AppError {
  constructor(service: string, message?: string) {
    super(
      message || `External service error: ${service}`,
      ErrorCodes.EXTERNAL_SERVICE_ERROR,
      502,
      { service }
    );
  }
}

// =============================================================================
// Logging
// =============================================================================

interface ErrorLogContext {
  error: Error;
  requestId?: string;
  userId?: string;
  path?: string;
  method?: string;
  body?: unknown;
}

/**
 * Log error with context
 */
function logError(context: ErrorLogContext): void {
  const { error, requestId, userId, path, method, body } = context;

  // In production, use a proper logger (Winston, Pino, etc.)
  const logEntry = {
    level: 'error',
    message: error.message,
    name: error.name,
    code: error instanceof AppError ? error.code : 'UNKNOWN',
    stack: error.stack,
    requestId,
    userId,
    path,
    method,
    // Don't log sensitive body data in production
    body: process.env.NODE_ENV === 'development' ? body : undefined,
    timestamp: new Date().toISOString(),
  };

  console.error(JSON.stringify(logEntry, null, 2));

  // In production, also send to error tracking service
  // e.g., Sentry, Bugsnag, etc.
  // if (process.env.NODE_ENV === 'production') {
  //   Sentry.captureException(error, { extra: logEntry });
  // }
}

// =============================================================================
// Express Error Handler
// =============================================================================

/**
 * Express error handling middleware
 *
 * @example
 * ```typescript
 * // Add as the last middleware
 * app.use(errorHandler);
 * ```
 */
export const errorHandler: ErrorRequestHandler = (
  error: Error,
  req: Request,
  res: Response,
  _next: NextFunction
): void => {
  // Convert to AppError if needed
  const appError = AppError.from(error);

  // Get request ID (assumes requestId middleware or similar)
  const requestId = (req as any).id || req.headers['x-request-id'] as string;

  // Log error
  logError({
    error: appError,
    requestId,
    userId: (req as any).user?.id,
    path: req.path,
    method: req.method,
    body: req.body,
  });

  // Don't expose internal error details in production
  const response = appError.toJSON(requestId);
  if (process.env.NODE_ENV === 'production' && !appError.isOperational) {
    response.error.message = 'An unexpected error occurred';
    delete response.error.details;
  }

  res.status(appError.statusCode).json(response);
};

/**
 * Express async route wrapper
 *
 * Wraps async route handlers to properly catch errors
 *
 * @example
 * ```typescript
 * app.get('/users/:id', asyncHandler(async (req, res) => {
 *   const user = await userService.getById(req.params.id);
 *   res.json({ data: user });
 * }));
 * ```
 */
export function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<unknown>
) {
  return (req: Request, res: Response, next: NextFunction): void => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// =============================================================================
// Next.js Error Handler
// =============================================================================

type NextApiHandler = (
  request: NextRequest
) => Promise<NextResponse> | NextResponse;

/**
 * Next.js API route error handler wrapper
 *
 * @example
 * ```typescript
 * export const GET = withErrorHandler(async (req) => {
 *   const data = await riskyOperation();
 *   return NextResponse.json({ data });
 * });
 * ```
 */
export function withErrorHandler(handler: NextApiHandler): NextApiHandler {
  return async (request: NextRequest): Promise<NextResponse> => {
    try {
      return await handler(request);
    } catch (error) {
      const appError = AppError.from(error);
      const requestId = request.headers.get('x-request-id') || undefined;

      // Log error
      logError({
        error: appError,
        requestId,
        path: request.nextUrl.pathname,
        method: request.method,
      });

      // Create response
      const response = appError.toJSON(requestId);
      if (process.env.NODE_ENV === 'production' && !appError.isOperational) {
        response.error.message = 'An unexpected error occurred';
        delete response.error.details;
      }

      return NextResponse.json(response, { status: appError.statusCode });
    }
  };
}

// =============================================================================
// Error Recovery Utilities
// =============================================================================

interface RetryOptions {
  maxAttempts?: number;
  delayMs?: number;
  backoffMultiplier?: number;
  shouldRetry?: (error: Error) => boolean;
}

/**
 * Retry an async operation with exponential backoff
 *
 * @example
 * ```typescript
 * const result = await withRetry(
 *   () => fetchExternalApi(),
 *   { maxAttempts: 3, delayMs: 1000 }
 * );
 * ```
 */
export async function withRetry<T>(
  fn: () => Promise<T>,
  options: RetryOptions = {}
): Promise<T> {
  const {
    maxAttempts = 3,
    delayMs = 1000,
    backoffMultiplier = 2,
    shouldRetry = () => true,
  } = options;

  let lastError: Error;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt === maxAttempts || !shouldRetry(lastError)) {
        throw lastError;
      }

      const delay = delayMs * Math.pow(backoffMultiplier, attempt - 1);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
}

/**
 * Execute with timeout
 *
 * @example
 * ```typescript
 * const result = await withTimeout(
 *   () => slowOperation(),
 *   5000,
 *   'Operation timed out'
 * );
 * ```
 */
export async function withTimeout<T>(
  fn: () => Promise<T>,
  timeoutMs: number,
  message: string = 'Operation timed out'
): Promise<T> {
  return Promise.race([
    fn(),
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new AppError(message, ErrorCodes.SERVICE_UNAVAILABLE, 504)), timeoutMs)
    ),
  ]);
}

// =============================================================================
// Default Export
// =============================================================================

export default {
  AppError,
  ValidationError,
  UnauthorizedError,
  ForbiddenError,
  NotFoundError,
  ConflictError,
  RateLimitError,
  DatabaseError,
  ExternalServiceError,
  errorHandler,
  asyncHandler,
  withErrorHandler,
  withRetry,
  withTimeout,
  ErrorCodes,
};
