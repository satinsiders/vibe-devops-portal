/**
 * {{SERVICE_NAME}} Service
 *
 * {{SERVICE_DESCRIPTION}}
 *
 * @example
 * ```typescript
 * const {{SERVICE_NAME_CAMEL}}Service = new {{SERVICE_NAME}}Service(dependencies);
 * const result = await {{SERVICE_NAME_CAMEL}}Service.create(data);
 * ```
 *
 * Template Placeholders:
 * - {{SERVICE_NAME}}: PascalCase service name (e.g., User, Order, Payment)
 * - {{SERVICE_NAME_CAMEL}}: camelCase service name (e.g., user, order, payment)
 * - {{SERVICE_DESCRIPTION}}: Brief description of service purpose
 * - {{ENTITY_TYPE}}: The main entity type this service manages
 * - {{REPOSITORY_TYPE}}: The repository type for data access
 */

import { z } from 'zod';

// =============================================================================
// Types
// =============================================================================

/**
 * Entity type managed by this service
 */
export interface {{SERVICE_NAME}}Entity {
  id: string;
  // {{ENTITY_TYPE}} - Add entity properties
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Input for creating a new entity
 */
export interface Create{{SERVICE_NAME}}Input {
  // Add create input properties
}

/**
 * Input for updating an entity
 */
export interface Update{{SERVICE_NAME}}Input {
  // Add update input properties (all optional)
}

/**
 * Query filters for listing entities
 */
export interface {{SERVICE_NAME}}Query {
  page?: number;
  perPage?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  // Add filter properties
}

/**
 * Paginated list result
 */
export interface {{SERVICE_NAME}}ListResult {
  data: {{SERVICE_NAME}}Entity[];
  meta: {
    page: number;
    perPage: number;
    total: number;
    totalPages: number;
  };
}

// =============================================================================
// Validation Schemas
// =============================================================================

export const Create{{SERVICE_NAME}}Schema = z.object({
  // Add validation rules
  // name: z.string().min(1).max(100),
});

export const Update{{SERVICE_NAME}}Schema = z.object({
  // Add validation rules (all optional)
  // name: z.string().min(1).max(100).optional(),
});

// =============================================================================
// Error Classes
// =============================================================================

export class {{SERVICE_NAME}}NotFoundError extends Error {
  constructor(id: string) {
    super(`{{SERVICE_NAME}} with ID ${id} not found`);
    this.name = '{{SERVICE_NAME}}NotFoundError';
  }
}

export class {{SERVICE_NAME}}ValidationError extends Error {
  constructor(
    message: string,
    public readonly details: Record<string, string[]>
  ) {
    super(message);
    this.name = '{{SERVICE_NAME}}ValidationError';
  }
}

export class {{SERVICE_NAME}}ConflictError extends Error {
  constructor(message: string) {
    super(message);
    this.name = '{{SERVICE_NAME}}ConflictError';
  }
}

// =============================================================================
// Repository Interface
// =============================================================================

/**
 * Repository interface for {{SERVICE_NAME}} data access
 * Implement this interface with your actual database layer
 */
export interface {{SERVICE_NAME}}Repository {
  findById(id: string): Promise<{{SERVICE_NAME}}Entity | null>;
  findMany(query: {{SERVICE_NAME}}Query): Promise<{{SERVICE_NAME}}ListResult>;
  create(data: Create{{SERVICE_NAME}}Input): Promise<{{SERVICE_NAME}}Entity>;
  update(id: string, data: Update{{SERVICE_NAME}}Input): Promise<{{SERVICE_NAME}}Entity>;
  delete(id: string): Promise<void>;
  count(query?: Partial<{{SERVICE_NAME}}Query>): Promise<number>;
}

// =============================================================================
// Service Class
// =============================================================================

/**
 * {{SERVICE_NAME}}Service
 *
 * {{SERVICE_DESCRIPTION}}
 *
 * This service layer contains business logic and orchestrates operations
 * between the controller/handler layer and the repository/data layer.
 */
export class {{SERVICE_NAME}}Service {
  constructor(
    private readonly repository: {{SERVICE_NAME}}Repository
    // Add other dependencies: eventBus, cache, etc.
  ) {}

  // ---------------------------------------------------------------------------
  // Read Operations
  // ---------------------------------------------------------------------------

  /**
   * Get a single entity by ID
   *
   * @throws {{SERVICE_NAME}}NotFoundError if entity doesn't exist
   */
  async getById(id: string): Promise<{{SERVICE_NAME}}Entity> {
    const entity = await this.repository.findById(id);

    if (!entity) {
      throw new {{SERVICE_NAME}}NotFoundError(id);
    }

    return entity;
  }

  /**
   * Get a single entity by ID, or null if not found
   */
  async findById(id: string): Promise<{{SERVICE_NAME}}Entity | null> {
    return this.repository.findById(id);
  }

  /**
   * List entities with pagination and filtering
   */
  async list(query: {{SERVICE_NAME}}Query = {}): Promise<{{SERVICE_NAME}}ListResult> {
    const normalizedQuery: {{SERVICE_NAME}}Query = {
      page: query.page ?? 1,
      perPage: Math.min(query.perPage ?? 20, 100), // Max 100 per page
      sortBy: query.sortBy ?? 'createdAt',
      sortOrder: query.sortOrder ?? 'desc',
      ...query,
    };

    return this.repository.findMany(normalizedQuery);
  }

  // ---------------------------------------------------------------------------
  // Write Operations
  // ---------------------------------------------------------------------------

  /**
   * Create a new entity
   *
   * @throws {{SERVICE_NAME}}ValidationError if input is invalid
   * @throws {{SERVICE_NAME}}ConflictError if entity already exists
   */
  async create(input: Create{{SERVICE_NAME}}Input): Promise<{{SERVICE_NAME}}Entity> {
    // Validate input
    const validationResult = Create{{SERVICE_NAME}}Schema.safeParse(input);
    if (!validationResult.success) {
      throw new {{SERVICE_NAME}}ValidationError(
        'Invalid input',
        this.formatZodErrors(validationResult.error)
      );
    }

    const validatedData = validationResult.data;

    // Business logic validations
    // e.g., check for duplicates, validate relationships, etc.

    // Create entity
    const entity = await this.repository.create(validatedData);

    // Side effects
    // e.g., emit events, send notifications, update cache

    return entity;
  }

  /**
   * Update an existing entity
   *
   * @throws {{SERVICE_NAME}}NotFoundError if entity doesn't exist
   * @throws {{SERVICE_NAME}}ValidationError if input is invalid
   */
  async update(
    id: string,
    input: Update{{SERVICE_NAME}}Input
  ): Promise<{{SERVICE_NAME}}Entity> {
    // Verify entity exists
    await this.getById(id);

    // Validate input
    const validationResult = Update{{SERVICE_NAME}}Schema.safeParse(input);
    if (!validationResult.success) {
      throw new {{SERVICE_NAME}}ValidationError(
        'Invalid input',
        this.formatZodErrors(validationResult.error)
      );
    }

    const validatedData = validationResult.data;

    // Business logic validations
    // e.g., check permissions, validate state transitions

    // Update entity
    const entity = await this.repository.update(id, validatedData);

    // Side effects
    // e.g., emit events, invalidate cache

    return entity;
  }

  /**
   * Delete an entity
   *
   * @throws {{SERVICE_NAME}}NotFoundError if entity doesn't exist
   */
  async delete(id: string): Promise<void> {
    // Verify entity exists
    await this.getById(id);

    // Business logic checks
    // e.g., check if entity can be deleted, handle cascading

    // Delete entity
    await this.repository.delete(id);

    // Side effects
    // e.g., emit events, cleanup related data
  }

  // ---------------------------------------------------------------------------
  // Business Operations
  // ---------------------------------------------------------------------------

  // Add domain-specific methods here
  // e.g., activate(), deactivate(), transfer(), etc.

  // ---------------------------------------------------------------------------
  // Private Helpers
  // ---------------------------------------------------------------------------

  /**
   * Format Zod validation errors into a more usable structure
   */
  private formatZodErrors(error: z.ZodError): Record<string, string[]> {
    const errors: Record<string, string[]> = {};

    for (const issue of error.issues) {
      const path = issue.path.join('.');
      if (!errors[path]) {
        errors[path] = [];
      }
      errors[path].push(issue.message);
    }

    return errors;
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * Create a {{SERVICE_NAME}}Service instance with dependencies
 */
export function create{{SERVICE_NAME}}Service(
  repository: {{SERVICE_NAME}}Repository
): {{SERVICE_NAME}}Service {
  return new {{SERVICE_NAME}}Service(repository);
}

// =============================================================================
// Default Export
// =============================================================================

export default {{SERVICE_NAME}}Service;
